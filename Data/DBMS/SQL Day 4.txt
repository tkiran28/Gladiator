DDL: data definition language: create,alter,drop,truncate,rename
DDL is used to define or modify the structure of the database objects(table,view,procedure,functions..)
--table constraint
	-entity integrity
	-referential integrity
	-domain integrity
	-default 


https://www.guru99.com/dbms-keys.html


Schema for banking application(customer,account,transactions)
*follow naming convention for column name dont use cust_id and so on
so that other can understand by other
*attribute(lowercase and _ separated) by oracle
primary key will always be numeric (good practice)
create table customer
(
customer_id number(6) primary key, --autogenerated column -- entity integrity -- numeric datatype takes a range from 1 to 38 


--read more about char,varchar(2000 bytes),varchar2(4000 bytes)
customer_name varchar2(100) not null,-- not null constraint 
customer_age number check(customer_age >18) --- check is called domain integrity constraint
customer_phone varchar2(10) check(length(customer_phone) =10),
customer_city varchar2(100) default 'Mumbai' --default customer
)

create sequence customer_seq start with 1001 increment by 1

DML
insert into customer values(customer_seq.nextval,'John',23,1234567890,'Mumbai')

partial insert
insert into customer(customer_id,customer_name,customer_age,customer_phone)
values(customer_seq.nextval,'Jerry',20,'9874778289')


//in  muliple insertion customer_Seq will not work
insert all into customer(customer_id,customer_name,customer_age,customer_phone)
values(customer_seq.nextval,'peter',25,'6536772865','Chennai')


insert all into customer(customer_id,customer_name,customer_age,customer_phone)
values(customer_seq.nextval,'James',24,'6636772865','Paris')

select * from dual //why bcoz inserting too many values we are creating a temporary table to create a batch or sequence of insert query

insert into customer values(customer_seq.nextval,'John',23,1234567890,'Mumbai')// after multiple insertion it will give error bcoz it will generate the manually entered seq no in above query first and not store duplicate seq no and then when unique value will generated it will insert a record

imp - customer_phone is not taking part in arthimetic operation so varchar2
if numeric which require large same so we prefer varchar2

*entity integrity
each object in this world are unique hence they should be uniquely identified 

*candidate key : columns which are eligible to become a primary key
before deciding pk all the key eligible to become pk are candidate key 

*alternate key : out of all candidate key one is chosen as primary key and remaining are consideres as alernate key

foreign and primary key column name must not be same but type must be same
create table account(
account_no number(10) 
account_type varchar2(20),--check(account_type in('current','saving')) -- current or saving
balance number(10,2) --10,000,000.00 -- out of 10, 2 will be in decimal  
customer_id number(6) references customer(customer_id)--- referential integrity constriant
constraint acc_pk  primary key (account_no)  -- constraint <constraint-name> <constraint-type> <column-name> --another way of writing primary key
)
// we create sequence bcoz we dont want user to enter primary key
create sequence account_seq start with 2001 increment by 1


insert into accounts values(account_seq.nextval,


Alter command: if we want to modify the structure of the table 

alter table account add constraint acc_type_chk check(account_type in('current','saving'))


alter table account modify account_type varchar2(30)

alter table account modify balance number(12,2) not null


create table transaction (
transaction_id number(30),--primary key
transaction_date date default sysdate,
transaction_type varchar2(50) check(transaction_type in('debit','credit')),
amount number(12,2) not null,
acc_no number(10) --column name in account table is account_no
)
select * from sys.user_constraints 

select constraint_name,constraint_type from sys.user_constraints where lower(table_name)='transactions'

alter table transaction drop constraint tra

alter table transaction drop column amount


rename transcation to tra


---anamolies
1.insert
2.update
3.delete

select * from customer 



insert into account values(account_seq.nextval,'savings',10000,1008)


create sequence tx_seq start with 3000 increment by 1
insert into transaction(transaction_id,transaction_type,acc_no,amount)
values(tx_seq.nextval,'debit',2001,5000)


delete from account where account_no=2001

1. on delete/update cascade : it will perform the same operation in child record
we can apply this while declaring foreign key constraint 


we can modify or drop and then add the constraint
alter table transaction drop constraint tra

alter table transaction add constraint trn_frk foreign key (acc_no) references account(account_no) on delete cascade on update cascade



select * from transactions

delete account where account_no=2002


Truncate --DDL

1. It is used to delete rows from the table
2. in delete we can have where clause to delete specific row but in truncate we cannot use where rows it will delete all the rows
3. if used truncate ,operation cannot be rolled back but in case of delete we can recover the rows
4. in case of truncate it cleans up the memory space
5.in delete/truncate we are working on data so why not dml and why ddl
ddl bcoz truncate drops the table and re-create it
sequence in case of truncate re-initializes happens??????????????
in real world people dont use truncate

DCL(data control language)
TCL(transaction control language)
read from reference material



ACID
atomic:all or none
consistency: data must be consistent
isolation:any transaction should happen in isolation(lock)
durability:changes should persist
save transaction prevent rollback


PL/SQL
programming in oracle
declare variable,constructs(if,switch,looping statement,break,continue)
we create PL/SQL blocks: set of instructions

two types of block
1.unnamed/anonymous (compiled and executed again and again)
2.named(compiled once and executed many times)

1.
three parts
1.begin
2.exception
3.end


begin



exception ---optional 


end;


begin
	dbms_output.put_line('Hello PL/SQL');
end;
// the above code will give output in sqllive

but to get in oracle
we have to write set SERVEROUTPUT ON

begin
	dbms_output.put_line(10+30);
end;


declare num1 number(10):=10;
	num2 number(10):=30;
begin 
	dbms_output.put_line('sum'||(num1+num2));
end;

************************************anything added with null is null

declare num1 number(10);
	num2 number(10) default 20;
begin 
    num1:=10;

	dbms_output.put_line('sum'||(num1+num2));
end;

o/p :30


eclare num1 number(10);
	num2 number(10) default 20;
begin 
    num1:=10;
    num2:=70
	dbms_output.put_line('sum'||(num1+num2));
end;

o/p:80
----------------------------------------------------------------
create table emps as select * from hr.employees
select * from emps
------------------------------
declare 
	emp_id number(10);
	emp_fname varchar2(50);

begin
	--emp_id:=100;
	select first_name into emp_fname from emps where employee_id=100;
	dbms_output.put_line(emp_fname);
end;


declare -------optional
	emp_id emps.employee_id%type;
	emp_fname emps.first_name%type;
	emp_lname emps.last_name%type;
	emp_salary emps.salary%type;

begin
	emp_id:= :eid;
	select first_name,last_name,salary into emp_fname,emp_lname,emp_salary from emps where employee_id=emp_id;
	dbms_output.put_line(emp_fname||' '|| emp_lname||' '||emp_salary);
end;


-----------------------------------------------------------------------------------------------------------------------------------------------------
Day 5

rowtype

declare
	emp_rec emps%rowtype;
	emp_fname emps.first_name%type;
begin
	emp_fname =&first_name
	select * into emp_rec from emps where first_name=emp_fname
	dbms_output.put_line(emp_rec.email);
end;



constructs : if , if else, if elsif else


declare
	emp_rec emps%rowtype;
	emp_fname emps.first_name%type;
begin
	select * into emp_rec from emps where first_name='Neena';
	if emp_rec.commission_pct is null then 
    	dbms_output.put_line('sorry you dont have commission');
    else
        dbms_output.put_line('you have commission');
	end if;
end;



declare
	emp_rec emps%rowtype;
	emp_fname emps.first_name%type;
begin
	select * into emp_rec from emps where first_name='Neena';
	if emp_rec.salary > 15000 then 
    		dbms_output.put_line('high salary');
	elsif emp_rec.salary > 10000 then 
		dbms_output.put_line('avg salary');
    	else
        	dbms_output.put_line('low salary');
	end if;
end;





declare
	emp_rec emps%rowtype;
	emp_fname emps.first_name%type;
begin
	select * into emp_rec from emps where first_name='Neena';
	if emp_rec.commission_pct is null then 
    		dbms_output.put_line((emp_rec.salary*12));
    else
        	dbms_output.put_line(((emp_rec.salary+emp_rec.salary*emp_rec.commission_pct)*12));
	end if;
end;
emp_sal:=emp_rec.salary*12


Two types of case
1.simple case/select case
2.search case


1.
select employee_id,first_name,job_id,
(case job_id
when 'AD_PRES' then 'Additional President'
when 'AD_VP' then 'Additional Vice President'
when 'IT_PROG' then 'Programmer'
else 'N/A'
end) as job_Details

from emps where employee_id <110


select employee_id,department_id,
    (case department_id
        when 10 then 'Administration'
        when 20 then 'Marketing'
        when 30 then 'Purchasing'
        when 40  then 'Human Resources'
    else 'Unknown'
end )  as dep_name
from emps 
in pl/sql default is else
2.search case

select employee_id,first_name,salary,
	case
		when salary >15000 then 'high salary'
		when salary >10000 then 'avg salary'
		when salary <10000 then 'low salary'
	end
from emps



declare
	sal_grade varchar2(50);
	sal emps.salary%type;
begin
	select salary into sal from emps where employee_id =110;
	sal_grade:=case
		when salary >15000 then 'high'
		when salary >10000 then 'avg '
		when salary <10000 then 'low '
	end;
	dbms_output.put_line('your salary'||sal||' comes under ' ||sal_grade||'gradde');
end;


iterations
for,while,loop


begin
	for i in 1..10 loop
	dbms_output.put_line(i);
	end loop;
end;


------------
declare
	i number:=1;
begin
	while  i<10 loop
		dbms_output.put_line(i);
		i:=i+1;

	end loop;
end;
-----------
declare
	i number:=1;
begin
	while  true loop
		dbms_output.put_line(i);
		i:=i+1;
		if i >10 then
		    exit;
		end if ;

	end loop;
end;
-----------------
declare
	i number:=1;
begin
	loop 
		dbms_output.put_line(i);
		i:=i+1;
		if i >15 then
		    exit;
		end if ;

	end loop;
end;
-------------------------------
find sum of n terms


declare
	last_num number(3):=5;
	res number(6):=0;
	i number(3):=1;


begin

	loop
		res:=res+i;
		i:=i+1;
		if i >last_num then
			exit;
		end if;
	end loop;
	
	dbms_output.put_line(res);
end;


declare
	last_num number(3):=5;
	res number(6):=0;
	i number(3):=1;


begin

	loop
		res:=res+i;
		i:=i+1;
		if i >last_num then
			goto endstatement;
		end if;
	dbms_output.put_line('sum'||res);
	end loop;
	
	dbms_output.put_line('final'||res);
	<<endstatement>>
	null;
end;

___________________________________



declare  
res number(3):=0;  
nm number(2):=5;  
begin  
<<startstatement>>  
res:=res+nm;  
nm:=nm-1;  
if nm>0 then  
goto startstatement;  
else  
goto endstatement;  
end if;  
<<endstatement>>  
DBMS_OUTPUT.PUT_LINE('Sum= '||res);  
end;

--------------------------------------------------------------------------
exception handling
declare
	emp_rec emps%rowtype;
	emp_fname emps.first_name%type;
	emp_lastname char(3);
begin
	select * into emp_rec from emps where first_name='Neena';
	select last_name into emp_lastname from emps where first_name='Neena';
	if emp_rec.commission_pct is null then 
    		dbms_output.put_line((emp_rec.salary*12));
    	else
        	dbms_output.put_line(((emp_rec.salary+emp_rec.salary*emp_rec.commission_pct)*12));
	end if;
    	exception
		when too_many_rows then dbms_output.put_line('multiple records found');
		when no_data_found then dbms_output.put_line('employee not found');
		when others then dbms_output.put_line('unknown exception');
end;
-----------------------------
declare
	emp_rec emps%rowtype;
	emp_fname emps.first_name%type;
	emp_lastname char(3);
begin
	select * into emp_rec from emps where first_name='Neena';
	select last_name into emp_lastname from emps where first_name='Neena';
	if emp_rec.commission_pct is null then 
    		dbms_output.put_line((emp_rec.salary*12));
    	else
        	dbms_output.put_line(((emp_rec.salary+emp_rec.salary*emp_rec.commission_pct)*12));
	end if;
    	exception
		when too_many_rows then dbms_output.put_line('multiple records found');
		when no_data_found then dbms_output.put_line('employee not found');
		when others then dbms_output.put_line('unknown exception');
	dbms_output.put_line('end of block');	
end;

//only if last exception occur then only end od block will be printed

-----------------------------------------------

cursors( to iterate through record)--point to the current record 
types of cursor (forward cursors)
implicit
explicit 



explicit cursor
list all the employee who are drawing salary less than a specific amount 


declare 
	emp_rec emps%rowtype;
	emp_sal emps.salary%type:=5000;

begin
	for emp_cur in (select * from emps where salary<emp_sal) -- for cursor 
	loop
		dbms_output.put_line(emp_cur.employee_id||' '||emp_cur.salary);

	end loop;


end;
---------------------------------------------------------------------

display employee_id,salary and commission_pct of all employees who do not earn commission



begin
	for emp_cur in (select * from emps where commission_pct is null) -- for cursor 
	loop
		dbms_output.put_line(emp_cur.employee_id||' '||emp_cur.salary||' '||nvl(emp_cur.commission_pct,0));

	end loop;


end;
---------------------------------------------------------------------
declare
	cursor emp_cur is select * from emps where department_id =60;
	emp_rec emps%rowtype;
begin
	open emp_cur ;
	loop
    	fetch emp_cur into emp_rec;
    	exit when emp_cur%notfound;
    	dbms_output.put_line(emp_rec.employee_id||' ' ||emp_rec.first_name);
    end loop;
	dbms_output.put_line(emp_cur%rowcount);
	close emp_cur;
	    

end;

-----------------------------------------------------------------

write a cursor to update the commission_pct based on below condition 
if no commission and salary is less than 5000 then add 3% commission
if no commission and salary is less than 10000 then add 2% commission
if commission and salary is less than 5000 then add 1% 
if commission and salary greater than and equal to 5000 no record updation

declare
	cursor emp_curr is select * from emps for update;
	emp_rec emps%rowtype;
	new_comm emps.commission_pct%type;
begin
	open emp_curr ;
	loop
        fetch emp_curr into emp_rec;
        exit when emp_curr%notfound;
    	if emp_rec.commission_pct is null and emp_rec.salary <5000 then
    		new_comm:=0.03;
    	elsif  emp_rec.commission_pct is null and emp_rec.salary <10000 then
    		new_comm:=0.02;
    	elsif	emp_rec.commission_pct is not null and emp_rec.salary <5000 then
    		new_comm:=0.01;
    	else
	    	new_comm:=0;
	    end if;
	    dbms_output.put_line('before'||' ' ||emp_rec.commission_pct);
        update emps set commission_pct=new_comm where current of emp_curr;
        dbms_output.put_line('after'||' ' ||emp_rec.commission_pct);
    dbms_output.put_line(emp_curr%rowcount);
    	
  	end loop;
	close emp_curr;
end;
-------------------------------------------------------------------

DECLARE  
cursor emp_cur IS SELECT * FROM emp FOR UPDATE;  
new_comm emps.commission_pct%type;  
BEGIN  
FOR emp_curr IN emp_cur  
LOOP  
IF emp_curr.commission_pct IS NULL AND emp_curr.salary < 5000  
THEN new_comm := 0.03;  
ELSIF emp_curr.commission_pct IS NULL AND emp_curr.salary < 10000  
THEN new_comm := 0.02;  
ELSIF emp_curr.commission_pct IS NOT NULL AND emp_curr.salary < 5000  
THEN new_comm := NVL(emp_curr.commission_pct, 0) + 0.01;  
ELSE  
new_comm := NVL(emp_curr.commission_pct, 0) + 0;  
END IF;  
UPDATE emp SET commission_pct = new_comm WHERE CURRENT OF emp_cur;  
END LOOP;  
END;  
--------------------------------------------------------------------------------

implicit cursor


declare
	

begin
	update emps set salary = salary+100 where department_id =100;
	dbms_output.put_line('no of rows affected :'||' ' ||sql%rowcount);
	
end;


----------------------------------------------------------------------------------

declare
	emp_rec emps%rowtype;
begin
	select * into emp_rec from emps where employee_id=100;

	if sql%found then
		dbms_output.put_line('record found');

	end if;
	exception 
		when NO_DATA_FOUND then
		if sql%notfound then
			dbms_output.put_line('record not found');
		end if;

end;

-----------------------------------------------------
parameterized cursor


declare
	cursor emp_cur(dept_id in emps.department_id%type) 
	is 
	select * from emps where department_id=dept_id;
	emp_rec emps%rowtype;


	
begin
	open emp_cur(100);
	loop
		fetch emp_cur into emp_rec;
		exit when emp_cur%notfound;
		dbms_output.put_line(emp_rec.employee_id||' '||emp_rec.department_id);

	end loop;
	close emp_cur;
end;
------------------------------
why unnamed block 

for testing purpose
--------------------------------
named blocks
procedures,triggers,functions,packages

create procedure p1
as/is ----both works 
begin
	dbms_output.put_line('procedure called');

end;
once created cannot be changed

drop it and change it
so write 
create or replace procedure p1
as
begin
	dbms_output.put_line(' my procedure called');

end;

execute it as ----exec p1

procedures are basically used to execute dml operation
while functions are basically used for calculation or processing thing and must return value


procedure can return value but they are not used for that


create or replace procedure addition(num1 in number,num2 in number,res out number)
is
	--res number(8):=0;
begin
	res:=num1+num2;
	--dbms_output.put_line('sum'||res);
end;
declare
r number(8):=0;
begin
exec addition(10,20,r)
dbms_output.put_line('sum'||r);

end;

---------------------------------------------------------
create or replace procedure addition(num1 in number,num2 in number,res out number)
is
	--res number(8):=0;
begin
	res:=num1+num2;
	--dbms_output.put_line('sum'||res);
end;
declare
r number(8):=0;
begin
addition(10,20,r);
dbms_output.put_line('sum'||r);
end;



-----------------------------------------------------------
create or replace procedure findSquare(side inout number)
as
begin
	side:=side*side;
end;

declare
	s number(5,2):=4;---- taking value from user
begin

	findsquare(s);
	dbms_output.put_line('square'||s);
end;

-----------------------------------------------------------------

create or replace procedure incr_salary(dept_id in number ,pct in number,rec out number)
as 
begin
	
	update emps set salary=salary+salary*pct where department_id = dept_id;
	rec := sql%rowcount;

end;
declare
	rec number(5);
	
begin
	incr_salary(90,0.1,rec);
	dbms_output.put_line(rec||'employees salary incremented');

end;

paytm wallet example 
----------------------------------------------------------------------------------

the above procdure using cursor


create or replace procedure incr_salary_by_employee(empsal in number,pct in number)
as
	cursor emp_cur(esal in emps.salary%type) is select * from emps where salary<esal for update;---esal will be of type salary in emps
	emp_rec emps%rowtype;

begin
	open emp_cur(empsal);----empsal will go to esal
	loop
		fetch emp_cur into emp_rec;
		exit when emp_cur%notfound;
		update emps set salary=salary+salary*pct where current of emp_cur;
	end loop;
	close emp_cur;
end;

exec incr_salary_by_employee(3000,0.1);

-----------------------------------------------------------------------------------

functions

create or replace function welcome(name in varchar2)

return varchar2
as
begin

    return 'welcome'||name;

end;
onne way to call
begin
dbms_output.put_line(welcome('kiran'));

end;
other way to call

select welcome('kiran') from dual;

------------------------------------------------------
write a function to return salary of an employee
create or replace function sal(empid in number)

return number
as
	sal number(10,2);
begin

    select salary into sal from emps where employee_id=empid;
    return sal;
end;

select sal(100) from dual;

function to return sum of salary of department
create or replace function sum_of_salary(deptid in number)

return number
as
	sal number(10,2);
begin

    select sum(salary) into sal from emps where department_id=deptid group by department_id;
    return sal;
end;

select sum_of_salary(90) from dual;
//assignment_plsql_name

--------------------------------------------------------------------
Triggers


(dropping a table also drops the associated triggers...just checked)



create or replace trigger trg_update_emps
after update on emps
for each row  --row level trigger

begin

	--dbms_output.put_line('row updated');

	dbms_output.put_line(:old.salary ||'is updated to '||:new.salary);
	insert into old_salary values(:old.employee_id,:old.salary);
end;
create table old_salary as select employee_id,salary from emps;
select * from old_salary
update emps set salary= salary+200 where department_id in(100,101,102,103);

-----------------------------------------------------------------------------

create table alumni as select employee_id,first_name from emps;
TRUNCATE TABLE alumni; 
create or replace trigger trg_delete_emps
after delete on emps
for each row
begin

	--dbms_output.put_line('row deleted');
	insert into alumni values(:old.employee_id,:old.first_name);
end;

delete from emps where employee_id=105;
select * from alumni
_---------------------------------------------------------------------

write a trigger to get fired only when salary is updated and check if increment amount is more than 
50% of current salary then we do not allow to update the salary


create or replace trigger update_salary
before update of salary on emps
for each row
declare
	cur_sal number(12,2);
	new_sal number(12,2);
begin
	cur_sal:=:old.salary;
	new_sal:=:new.salary;
	if new_sal >(cur_sal=cur_sal*0.5) then
		raise_application_error(-20100,'cannot update salary');
	else
		dbms_output.put_line('salary updated');
	end if;
end;


select * from emps

update emps set salary = 13500 where employee_id =120
---------------------------------------------------------------------




create or replace trigger trg_dropEmps
before drop on emps
begin
	raise_application_error(-20100,'cannot drop table');
end;













































































































































































































































































