========================================================================================================================================================
DAY_1 2nd SEP 2020  |
---------------------
SQL is Non-procedural language

select * from emp;


select * from emp where ename='ALLEN';



SELECT * FROM emp WHERE deptno= '20';



SELECT * FROM emp WHERE NOT  job = 'SALESMAN';
-- data is case sensitive. 'salesman' wont work it has to be 'SALESMAN'



SELECT * FROM emp WHERE HIREDATE='22-FEB-81';
SELECT * FROM emp WHERE HIREDATE='22-feb-81';
-- both above will work



select * from emp where job <> 'SALESMAN';
-- <> operator same as not equal



select * from emp where job ='CLERK' OR job ='MANAGER'
-- this is not allowed=>  select * from emp where job ='CLERK' AND job ='MANAGER';
-- DBMS follows ACID property. only one value in one box



SELECT * FROM emp WHERE empno= 7782 OR empno= 7698 OR empno= 7566 OR empno= 7788 OR empno= 7902;
-- or 
SELECT * FROM emp WHERE empno IN (7698,7782,7566,7788,7902);



SELECT * FROM emp WHERE sal BETWEEN 2000 AND 4000;
-- 'between' is inclusive. selecting both 2000 and 4000



select * from emp
where hiredate between '31-Jan-81' and '1-Dec-83'



SELECT * FROM emp WHERE sal>= 2000 AND sal<= 4000;



select * from emp where ename like 'S%';
-- pattern matching
select * from emp where ename like '_D%';
-- 2nd char as D 
select * from emp where ename like '____';
--4 char name



SELECT ename, sal, comm, sal+comm AS total_sal FROM emp;
--here comm is 'null'. so any calculation with null is null only. Hence total is null even if salary is present. 




select comm,  NVL( comm, 9 ) from emp;
-- NVL function- if comm has NULL value then only Replace it by 900. Otherwise kepp it as it is
-- works with string as well. hence you can replace null with 'AAA' or ny string



select empno, ename ,sal, comm, sal+NVL(comm,0) as total_sal from emp;
--NVL function- if comm has NULL value then only Replace it by 0.




select empno, ename, sal  from emp order by 2;
--ordered by 2nd column in select statement. here it is Ename


select ename , sal, sal*0.1 "PF", sal*05 "HRA", sal*0.3 "DA" 
from emp 
order by 5;



select ename,job,sal from emp 
where ( job='CLERK' OR JOB='MANAGER' ) and sal> 2500 
order by job, deptno;
-- () has higher precedence



select ename,job,sal from emp 
where job='CLERK' OR JOB='MANAGER' and sal> 2500 
order by job, deptno;



--() paranthesis has highest precedence.
-- NOT >  AND  > OR   precedence.


select ename || '  my  ' || job  as Combined from emp;
-- o/p: KING my MANAGER


select ename || q'[  it's ]' || job  as Combined from emp;
-- o/p:   KING  it's  MANAGER
-- Use q'[     ]'  if word contains quote in it.



from MEENAL to everyone:    3:52 PM
--single row functions /Scalar Functions
--char function
--(Character functions accept character input and return either character or number
select length('mymaster') from dual ;
select ename,length(ename) from emp;
select Lower('MYMaster') from dual ;
select Lpad('Mymaster',15,'*') from dual; --**Mymaster
select Rpad('Mymaster',15,'*') from dual; --Mymaster**
select  Rtrim('Mymaster','ster') from dual ; --Myma
select  Ltrim('Mymaster' ,'myma') from dual ;--Mymaster Dr. Mr. Mrs. 
select  Ltrim('Mymaster' ,'Myma') from dual ;--ster
select  substr('mymaster',3,4) from dual ;
select replace ('This and That', 'TH','b') from dual;-need exact match
select Translate('This and That', 'TH','b') from dual;
===============================================================================================================================================================
DAY_2 3rd SEP 2020  |
---------------------


Group by 
•    Columns listed in select statement apart from group by function have to be listed in group by clause
•    Columns listed in group by need not be listed in select statement 
•    Only group functions can be used in having clause and those function are need not
     be listed in select statement. In case you want to apply condition then use where
     clause before group by clause.


Precedence:
where > group by > having > order by > select



SQL JOINS FULL RESOURCES:
-------------------------
OUTER JOIN-
1) FULL outer
2) LEFT outer
3) Right outer
https://www.sqlshack.com/sql-outer-join-overview-and-examples/

INNER JOIN-
(form of equi join)
https://www.sqlshack.com/a-step-by-step-walkthrough-of-sql-inner-join/

EQUI JOIN-
(Duplicate column from both table included)
https://www.educative.io/edpresso/what-is-an-equi-join-in-sql

NON-EQUI JOIN-
https://www.w3resource.com/oracle/joins/oracle-non-equijoins.php


(Difference between equi and non-equi join):
https://sqlity.net/en/1430/a-join-a-day-equi-join-vs-nonequi-join/

NATURAL JOIN-
(form of equi join without duplicate column)
https://www.educative.io/edpresso/what-is-a-natural-join-in-sql

CARTESIAN JOIN & 
SELF JOIN-
https://www.google.com/amp/s/www.geeksforgeeks.org/sql-join-cartesian-join-self-join/amp/




LIVE SQL oracle queries:
-------------------------
select * from emp;

select deptno
from emp
group by deptno
having sum(sal)> 9000


select 
count(*) "A", 
count(job) "B",
count(comm) "C",
count(distinct job)"D" 
from emp;



CREATE TABLE SALGRADE (
 GRADE               NUMBER,
 LOSAL               NUMBER,
 HISAL               NUMBER);
INSERT INTO SALGRADE VALUES (1,700,1200);
INSERT INTO SALGRADE VALUES (2,1201,1400);
INSERT INTO SALGRADE VALUES (3,1401,2000);
INSERT INTO SALGRADE VALUES (4,2001,3000);
INSERT INTO SALGRADE VALUES (5,3001,999);

select * from salgrade;

select * from emp;

select * from dept




Select e1.ename, e2.ename
from emp e1, emp e2 
where e1.mgr=e2.empno
-- self join


-- cartesian join is oracle term. same as cross join
--Cartesian Product/Cross Join 
-- No need to mention CROSS word. oracle follws this one.
select e.ename , e.sal , d.dname , d.loc 
from emp e,dept d;



-- following for non- Oracle system
 SELECT ENAME,DNAME FROM EMP CROSS JOIN dept;
 

 
--Equi Join/Natural /Inner Join
-- should have same column name.
-- for oracle we write follow
select e.ename , e.sal , d.dname , d.loc from emp e, dept d
where e.deptno=d.deptno



--For Non-equi join, same column name is not necessary. But just 
datatype of column should be same.



-- for non-oracle system follow
select deptno,dname,loc from emp NATURAL JOIN dept;
select empno,ename,loc,deptno from emp JOIN dept USING (deptno);
select empno,ename,loc,dept.deptno from emp JOIN dept on( emp.deptno=dept.deptno)



--OUTER JOIN
-- also called as- equi join + null rows are added for unmatched columns 
-- all records from dept table and null records from emp table added
--No matter if you switch left and right terms after where clause
Select * from dept d,emp e where e.deptno(+)=d.deptno;
Select * from dept d,emp e where d.deptno=e.deptno(+);
--same as follow
Select * from emp RIGHT OUTER JOIN dept ON (EMP.DEPTNO=DEPT.DEPTNO); 
Select * from dept left OUTER JOIN emp ON (EMP.DEPTNO=DEPT.DEPTNO); 




--all records from opposite side of + are added. and null are put for + side table
  if record not present.
--all records from emp table are added
Select  * from dept d,emp e where e.deptno=d.deptno(+);
Select e.ename,d.dname,d.deptno from dept d,emp e where d.deptno(+)=e.deptno;
--same as follows
Select ename,EMP.deptno,dname from dept RIGHT OUTER JOIN emp ON (EMP.DEPTNO=DEPT.DEPTNO);  -- all from emp
Select ename,EMP.deptno,dname from emp LEFT OUTER JOIN dept ON (EMP.DEPTNO=DEPT.DEPTNO);   -- all from emp .ie. left sided




--oracle follows following for full outer join
select ename,EMP.deptno,dname from 
emp FULL OUTER JOIN dept
 ON (EMP.DEPTNO=DEPT.DEPTNO);



select sqrt(16) from dual ;
SELECT ename, sal, MOD( sal, 100)  FROM emp ;
select power(3,2) from dual;
select greatest(10,40,20) from dual ;
select least(10,30,50) from dual ;

select replace ('This and That', 'TH','b') from dual;-- wont work because replace need exact match
select Translate('This and That', 'TH','b') from dual; --bhis and bhat.  replace to b for either T or H




select comm, NVL2(comm, 5000, 1000) from emp




--if length(job)=length(name) then write null otherwise column one value
SELECT ename, LENGTH(ename) "expr1", LENGTH(job) "expr2",
NULLIF( LENGTH ( ename), LENGTH( job) ) result  FROM emp;




-- Decode()
-- if match found then adding 5000 to matched column
select ename,empno,sal, job, decode( job, 'MANAGER', sal+5000) new_sal from emp;
--increases salary of manager by 5000 if not then 2000
select ename,empno,sal, job, decode( job, 'MANAGER', sal+5000,2000) new_sal from emp;
-- 
select job,sal,decode(job,'ANALYST',sal+1000,
                         'CLERK',SAL+100,
                          'MANAGER',sal+200,sal) "rev_sal"
from emp ORDER BY JOB;






--case
SELECT ename, job, sal,
CASE job WHEN 'CLERK' THEN sal+2000
           WHEN 'MANAGER' THEN sal+5000
           WHEN 'SALESMAN' THEN sal+3000
ELSE            
        sal
END "REVISED SALARY"
FROM emp;





--Set operators
--result of query 1 and query 2 are combined using UNIOIN operator. But discards duplicate 
select job from emp where deptno=20
union 
select job from emp where deptno=30




--Duplicates are added using union all
select job from emp where deptno=20
union all
select job from emp where deptno=30
-- selected coulumn in both queries should have same data types




--Unique values from 1st query
select job from emp where deptno=20
minus
select job from emp where deptno=30




--common values 
select job from emp where deptno=20
intersect
select job from emp where deptno=30
order by 1 desc


========================================================================================================================================================
DAY_3 4rth SEP2020|
-------------------




--SUB-QUERIES
--Types of sub-query(SQ) :
-- 1)songle row- inner query return one result  (= ,<=, >=, <, >)
-- 2)multi-row - iner row return multiple rows ( IN,  <any,  >any, <all, >all )
-- 3)Corelated Q
 Correlated sub queries are used for row-by-row processing:
•    Here each sub query is executed once for every row of the outer query.    
•    The oracle server performs a correlated subquery when the subquery references a  column from a table referred to in the parent statement.  
•    A correlated sub query is evaluated once for each row processed by the parent statement (query)
•    The parent statement can be a SELECT, UPDATE or DELETE statement.
•    A correlated subquery can return the same result as a self join, but can be used where a join cannot, such as in an UPDATE, INSERT and DELETE statement
•    as in corelated sub query the result is based on the outer query like every time the inner query is executed the outer query is executed and the data can be retrieved from two tables in subquery we can have different table and vice versa.



--Single-row SQ
select * from emp 
where deptno= (select deptno from emp where ename='ALLEN')
-- if subquery returns NULL or no records then whole query would give no records as well.



select * from emp 
where sal > (select deptno from emp where ename='ALLEN')
-- inner column(deptno) and outer column(sal) need not to be same. But their data types must be same.



select * from emp 
where ename>  (select job from emp where ename='ALLEN')
-- alphabet greater than S wale ename are selected



-- multi-row SQ
select * from emp 
where deptno IN  (select deptno from emp where job='CLERK')



--  <any = less than max
--  >any = greater than min
--  <all = less than min
--  >all = greater than max
select * from emp where sal >any (select sal from emp where JOB='CLERK');



-- Corelated SQ
-- outer table is parent Query table
-- outer parent query display result if inner query return true. and this is
-- done for each record. if match found ie. if true then outer query runs and display record.
select ename,job from emp e where EXISTS(select mgr from emp where(emp.mgr=e.empno));


mam, is 'EXISTS' the only specfic keyword used in case of corelated queries? aren't there any other examples?





--Date and Time functions
https://www.oracletutorial.com/oracle-date-functions/
select NEXT_DAY(SYSDATE, 'MONDAY') from dual;


-- sysdate is internally in systimestamp format so convert it into same type as hiredate to compare. Hiredate is in char format
select SYSDATE from dual      -- dd month yy
select SYSTIMESTAMP from dual  -- exact timestamp



select ADD_MONTHS(sysdate,4) from dual ;
Select NEXT_DAY(SYSDATE,'MONDAY') from dual;
Select NEXT_DAY(hiredate,'MONDAY') from emp where ename='SCOTT'; 
--pick hiredate from emp table and next day of it

select LAST_DAY(SYSDATE) from dual ;
Select hiredate,SYSDATE, GREATEST(hiredate,SYSDATE) from emp where ename='SCOTT';


If date1 is later than date2, then the result is positive.--5.705……
Oracle Database calculates the fractional portion of the result based  on a 31-day month and considers the difference in time components  date1 and date2. (even though month has 30/29 days)
Select SYSDATE,'23-Nov-07', MONTHS_BETWEEN (SYSDATE,'23-JAN-16') as “diff” from dual;
If date1 is earlier than date2, then the result is negative.


--List the names of employees who have joined in the year 1982.
    SELECT ename as "EMPLOYEE_NAME"
    FROM emp
    WHERE EXTRACT(YEAR FROM HIREDATE)=1982;

--List the name & experience (in years) of the employees who are working as CLERKS.
    SELECT ename as "EMPLOYEE_NAME", EXTRACT(YEAR FROM SYSDATE)-EXTRACT(YEAR FROM HIREDATE) as "EXPERIENCE"
    FROM emp
    WHERE job='CLERK';





select Round(MONTHS_BETWEEN('04-SEP-19',SYSDATE) )from dual;

select sysdate from dual ;
select * from emp where hiredate >'04-SEP-20';
insert into emp values(2222,'AAAA','CLERK',7566,'04-SEP-20',1500,500,10);

select * from emp where hiredate = to_char(SYSDATE);
select * from emp where to_char(hiredate) = to_char(SYSDATE);
-- sysdate is internally in systimestamp format so convert it into same type as hiredate to compare.




select sysdate, TO_CHAR (sysdate,'DAY') from dual;
select sysdate, TO_CHAR (sysdate,'YEAR') from dual;
 SELECT TO_CHAR(SYSDATE,'DDTH " OF " MONTH YYYY') "NEW" FROM DUAL;
 SELECT TO_CHAR(SYSDATE,'DDTH " OF " MON YYYY') "NEW" FROM DUAL;
 SELECT TO_CHAR(SYSDATE,'DDTH " OF " MONTH YY') "NEW" FROM DUAL;
 SELECT TO_CHAR(HIREDATE,'DDTH " OF " MONTH YYYY') "NEW" FROM EMP;
 SELECT ENAME,TO_CHAR(HIREDATE,'DDTH " OF " MONTH YYYY') "NEW" FROM EMP;
 SELECT ENAME,TO_CHAR(HIREDATE,'DDTH " OF " MONTH YYYY') "RECRUITED ON" FROM EMP;
 SELECT TO_DATE('19OCT1959','DD-MON-YYYY') FROM DUAL;
 SELECT TO_DATE('19OCTOBER1959','DD-MON-YYYY') FROM DUAL;
 SELECT TO_DATE('19OCTOBER1959','DD-MONTH-YYYY') FROM DUAL;
 SELECT TO_DATE('19OCTOBER1959','DDMONTHYYYY') FROM DUAL;
select TO_NUMBER('100') from dual ;




/* 
Naming conventions for columns
:Must  begin with letters 
:upto 30 char long 
: can have _, special chars like(@,#,$)
:can’t  have blank space 
:Not case sensitive 
:Should be unique 
:max 1000 column 
*/
Create table empn
(
Empno number(4) constraint empn_empno_uq UNIQUE,
Ename varchar2(10),
sal number(5) constraint empn_sal_check CHECK(sal >2000),
hiredate date DEFAULT sysdate ,
Deptno number(2) NOT NULL 
);


insert into empn values( 102,'Vijay',6000,'14-JAN-19', 10); -- manually 
insert into empn values( 103,'Vijay',6000,NULL, 10); -- manually null. Hence  Null overwrites sysdate
--below wont add default date into table. for that see next query
insert into empn values( 104,'sanjay',6000, 10);
-- Bellow I have mentioned column names after emp table so that even if hiredate is not mentioned, it will have default value.
insert into empn(Empno,Ename,sal, Deptno ) values( 104,'sanjay',6000, 10); 



--For DBA information
select * from USER_CONSTRAINTS where TABLE_NAME='EMPN'



Drop table MyDept

Create table MyDept
(
Dno number(2),
ser varchar2(10),
CONSTRAINT MyDept_Dno_pk PRIMARY KEY (Dno)
);
insert into MyDept values(10, 'HR');





Drop table MyEmp

Create table MyEmp
(
Empno number(4)  ,
Ename varchar2(10),
sal number(5) not null constraint chk_sal check(sal>5000),
hiredate date default sysdate,
Deptno number(2) not null,
constraints MyEmp_Empno_pk  primary key(Empno),
constraints MyEmp_Deptno_fk foreign key(Deptno) references MyDept(Dno)

);
insert into MyEmp values(10,'Vijay',6000,'14-JAN-19', 10);




-- Update 
update EMP
set JOB = 'MANAGER', DEPTNO = 20, SAL = SAL +1000
where ENAME = 'JONES';

update emp 
set deptno=(select deptno from dept where dname='BOSTON')
where ename='ALLEN';



-- this copies data into table QWERTY but constarints are not copied.
-- so you can insert null value as primary key.
create table QWERTY
as 
select * from emp




-- VIEW of table- virtual / view of table
create view v2
as 
select empno,ename,sal,deptno from emp

select * from v2

--Now changing value in base table emp
select * from emp
update emp 
set sal=10000 
where empno=7698

select * from emp 

--update in table emp also update values in view v2
select * from v2  



-- adding extra column mgr. so use OR REPLACE 
create OR REPLACE view v2
as 
select empno,ename,sal,deptno, mgr from emp

select * from v2
--also you cant insert in column of the view which is not in view. ie. 

-- with READ ONLY OPERATion
create view v3
as 
select empno,ename,sal,deptno from emp
with READ ONLY 

select * from v2

--cannot insert. because it is read only permission
insert into v3 values(10,'gggggg',33,333)



-- views with group by, joins, having clause cannot be performed.
-- they are called complex views

